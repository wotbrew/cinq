Indirect dbis

Give dbis int names. Have the associated keys be in a table. When we look up a variable, indirect through this table.

Benefits:
- can swap one variable out for another. I've prepped customers2, make it customers now as an atomic swap.
  Because such a table would be in the database we can even commit multiple such swaps at once. This might be useful in doing schema migs etc

---

Implicit group

(q [f foo] (c/count))

if let/proj/where/join/scan-src/group-expr/order-expr expr expects grouping, add it if is not already present

---

Indexes

index scans:
(q [f (get (:n foo) 42)])
(q [f (c/asc (:n foo) >= 42)])
(q [f (c/desc (:n foo) < 42 )])

(c/asc (:n foo) >= 42)

index sorts:
(q [f (c/asc (:n foo))])
(q [f (c/desc (:n foo))])

index nlj
(q [id (get (:id customers) 42)
    :left-join [o (get (:customer-id orders) c:id)]]
    [id o])

---

Spooling

spooled merge join
(q [c customers
    :join! [o orders (= o:customer-id c:customer-id]]
    [c o])

spooled group by
(q [c customers
    :group! [firstname c:firstname]]
    [firstname (c/count)])

spooled sorts
(q [c customers
    :order! [c:firstname :desc]]
    c:id)

---

CinqDynamicBigRecord
- used if map is big
- actual hash table with lazy value loads

---

CinqDynamicList
- perhaps for large lists, lazy decoding would be helpful

---

CinqDynamicSet
(same as maps)

---

Record specialisation (structs)

(c/defrecord Customer [a b c d e f])

adds an actual defrecord, with a type hint.
record name is mapped to a layout (array of name, type)

layouts are stored in the symbol table
records are stored as layout value* buffers

(q [^Customer c customers])
 provides a layout hint to (scan customers) so that decoder can be specialised

if layout hint not matched adapt to the record using map->X ?
Or perhaps emitted/hinted type should be an interface, which can have an adapter for a lazy record

---

Hardening

- variable limit (LMDB)
- symbol limit (warn and degrade?)

---

Datalog

For recursive queries, I think datalog would be a better fit than the sql-style cinq q.

Datalog definition will rely on semantics suggestive of 'applying a relation as a function'. This invokes a generative binding mode

(require '[com.wotbrew.cinq.datalog :as dlog])

form (dlog/q ?selection ?projection)

standard relation application is generative, either a from (first application) or a join.

(dlog/q [(customers {?id :id})] ?id))
=>
(q [{?id :id} (generate customers {})] ?id)

a generate call on a returns a relation, It is implemented by relations and by functions.

(dlog/q
 [(customers {?id :id, ?firstname :firstname})
  (= ?id 42)]
 ?firstname)
=>
(q [{?id :id, ?firstname :firstname} (generate customers {})
    :join [_ (generate = ?id 42)]
  ?firstname)

Top level relation application will be turned into (generate) calls, but for common predicates - or predicates that are flagged as such
can get optimised away into :when clauses.

Normal relations will accept unary argument with a map of bindings for generate. Datalog rules will accept positional arguments.

(q [{?id :id} (generate customers {})
    :when (= ?id 42)])

;; dependent joins can be optimised into joins by rewriting generate calls
(dlog/q
 [(customers {?id :id})
  (orders {?id :customer-id, :order-id ?o})]
 [?id ?o]
 )
;; =>
(q [{?id :id} (generate customers {})
    :join [{?o :order-id} (generate orders {?id :customer-id})]
  [?id ?o])

rule:
(generate ?relvar {}) == ?relvar
(q [{?id :id} customers
    :join [_ (generate orders {?id :customer-id})]
  [?id o:order-id])

rule:
(generate ?relvar {?var ?att ...})
:join [x ?relvar (= ?var x:?att)]

RULEDEF

Rules look like lambdas, arity-overload used for multiple bodies. Can be defined inline or def'd like views.

(dlog/q
   [(dlog/r ancestor
     ([?a ?b]
      (parent {:child ?a, :parent ?b}))
     ([?a ?c]
      (parent {:child ?a, :parent ?b})
      (ancestor ?b ?c)))
    (ancestor ?a "bob")]
    ?a
   )

is transformed to a cte expression.

(c/cte [ancestor (c/q [p parent] [p:child p:parent])
        ancestor (c/q [[?a ?b] ancestor
                       :join [[?b ?c] ancestor (= ?b ?c)])])]
  (c/q [[?a ?c0] ancestor
        :when (= ?c0 "bob")]
    ?a))

PROBLEM: macros, or, not etc?

---

Destructure numeric key

(q [[a b] foo] [a b])

vector destructures should leave a special (nth-lookup) form in the scan so that we choose nth over get or dispatch at runtime based
on whether associative?

---

Views / Rules

(c/defview ancestor [parent]
  parent
  (c/q [[a b] ancestor
        [c d] ancestor
        :when (= b c)]
        [a b]))

defines macro-like the ra
[:union parent $join]

Problems:
 - hygiene, do we need to gensym and unquote?
 - Perhaps all unresolvable globally unqualified symbols get renamed to gensym?

usage

(cte [parent2 [["bob" "phil"]]
      ancestor (ancestor parent2)]
   ancestor)

[:cte [[parent ...], [ancestor [:cte [[ancestor [:union parent $join]]]]]]]

rules:

flatten unions into same bind
flatten cte into cte

---

Non materialized CTE views

---

Mutual recursion

Not supported at the moment. How to make that fast?

Non recursivity carries to dependents, if a query/view is only dependent on non recursive queries it itself is non recursive
this would be a planner / ana change

---

Interrupted checks

Currently, if the loop gets out of control (CTE?) you are screwed as there are no interrupt checks.
This will likely be even more important later when you are scanning 2TB LMDB relations.

Putting interrupt checks naively on the main loop does come with a fairly significant perf cost or around 5%.

Think about what to do.
